ambiguous_custom_block_signature=Scratch l√§sst es zu, dass du mehrere eigene Bl√∂cke mit demselben Namen erstellst. Das Programm kann anschlie√üend nicht mehr zwischen den einzelnen Bl√∂cken unterscheiden. Verwende f√ºr eigene Bl√∂cke immer eindeutige Namen.
ambiguous_parameter_name_unused=Scratch l√§sst es zu, dass du die Eingabefelder von eigenen Bl√∂cken gleich benennst. Das Programm kann anschlie√üend nicht mehr zwischen den einzelnen Parametern unterscheiden. Verwende f√ºr Eingabefelder immer eindeutige Namen.
ambiguous_parameter_name_used=Scratch l√§sst es zu, dass du die Eingabefelder von eigenen Bl√∂cken gleich benennst. Verwende f√ºr Eingabefelder unbedingt eindeutige Namen.
backdrop_switch=Gut gemacht! Du hast nutzt den Wechsel zu einem anderen B√ºhnenbild auch um andere Skripte zu starten. Somit kannst du passende Aktionen je nach B√ºhne ausf√ºhren.
blocking_if_else=Du verwendest einen [sbi]stoppe [alles v][/sbi] oder [sbi]stoppe [dieses Skript v][/sbi] Baustein sowohl im [IF] als auch im [ELSE] Zweig dieses Bausteins. Das Skript terminiert also in jedem Fall und die Bl√∂cke nach dem [sbi]falls < > dann[/sbi] Baustein werden nie ausgef√ºhrt. Verwende nur in einem Zweig einen [sbi]stoppe [ v][/sbi] Baustein oder l√∂sche alle Bausteine nach dem [sbi]falls < > dann[/sbi].
blocking_if_else_inside_loop=Du verwendest einen [sbi]stoppe [alles v][/sbi] oder [sbi]stoppe [dieses Skript v][/sbi] Baustein sowohl im [IF] als auch im [ELSE] Zweig dieses Bausteins. Das Skript terminiert also in jedem Fall und die Wiederholung au√üerhalb des [sbi]falls < > dann[/sbi] Bausteins wird nie richtig ausgef√ºhrt. Verwende nur in einem Zweig einen [sbi]stoppe [ v][/sbi] Baustein oder entferne die Wiederholung.
boolean_expression=Super! Du verwendest Boolsche Ausdr√ºcke in deinem Program.
busy_waiting_all=In deinem Skript wird immer wieder die Bedingung √ºberpr√ºft, nur um bei positiver Auswertung alles zu beenden. Verwende statt Wiederholung und bedingter Anweisung einfach den [sbi]warte bis < >[/sbi] Baustein, um auf den Eintritt der Bedingung zu warten.
busy_waiting_clone=In deinem Skript wird immer wieder die Bedingung √ºberpr√ºft, nur um bei positiver Auswertung den Klon zu l√∂schen. Verwende statt Wiederholung und bedingter Anweisung einfach den [sbi]warte bis < >[/sbi] Baustein, um auf den Eintritt der Bedingung zu warten.
busy_waiting_script=In deinem Skript wird immer wieder die Bedingung √ºberpr√ºft, nur um bei positiver Auswertung das Skript zu beenden. Verwende statt Wiederholung und bedingter Anweisung einfach den [sbi]warte bis < >[/sbi] Baustein, um auf den Eintritt der Bedingung zu warten.
call_without_definition=Wenn ein eigener Block in Scratch gel√∂scht wird, bleiben manchmal Einsatzfragmente zur√ºck. Stelle sicher, dass du den eigenen Block an allen Positionen, an denen du ihn verwendest, ebenfalls l√∂schst.
clone_type_1=Die identischen Anweisungen existieren in mehreren Scripts. Ein eigener Block k√∂nnte den Code vereinfachen.
clone_type_2=Die gleichen Anweisungen, nur mit unterschiedlichen Parametern, existieren in mehreren Skripten. Ein eigener Block k√∂nnte den Code vereinfachen.
clone_type_3=√Ñhnlicher Code existiert in mehreren Skripten. Ein eigener Block k√∂nnte den Code vereinfachen.
collision=Gut gemacht! Deine Figur zeigt ein Verhalten, sobald es mit bestimmten Dingen in Ber√ºhrung kommt.
comparing_literals_default_false=Du vergleichst zwei Texte. Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: [FALSE]. Der Code im [bc]%THENELSE[/bc] Block wird %ALWAYSNEVER ausgef√ºhrt. Ersetze deinen Vergleich durch etwas Passenderes oder entferne die Kontrollstruktur.
comparing_literals_default_true=Du vergleichst zwei Texte. Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: [TRUE]. Der Code im [bc]%THENELSE[/bc] Block wird %ALWAYSNEVER ausgef√ºhrt. Der Block ist √ºberfl√ºssig.
comparing_literals_default_variable=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Deshalb wird der Code im [bc]%THENELSE[/bc] Block %ALWAYSNEVER ausgef√ºhrt. Wolltest du eine Variable [var]%VARIABLE[/var] im Vergleich verwenden? Dann lege diese in der Kategorie Variable an und verwende den neuen Baustein.
comparing_literals_default_variable_exists=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Deshalb wird der Code im [bc]%THENELSE[/bc] Block %ALWAYSNEVER ausgef√ºhrt. Wolltest du den Baustein f√ºr deine angelegte Variable [var]%VARIABLE[/var] im Vergleich verwenden?
comparing_literals_default_variable_exists_two=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Deshalb wird der Code im [bc]%THENELSE[/bc] Block %ALWAYSNEVER ausgef√ºhrt. Wolltest du die angelegte Variable [var]%VARIABLE1[/var] oder [var]%VARIABLE2[/var] im Vergleich verwenden?
comparing_literals_default_variable_exists_two_without_information=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Wolltest du die angelegte Variable [var]%VARIABLE1[/var] oder [var]%VARIABLE2[/var] im Vergleich verwenden?
comparing_literals_default_variable_exists_without_information=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Wolltest du den Baustein f√ºr deine angelegte Variable [var]%VARIABLE[/var] im Vergleich verwenden?
comparing_literals_default_variable_two=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Deshalb wird der Code im [bc]%THENELSE[/bc] Block %ALWAYSNEVER ausgef√ºhrt. Wolltest du die Variablen [var]%VARIABLE1[/var] oder [var]%VARIABLE2[/var] im Vergleich verwenden? Dann lege diese in der Kategorie Variable an und verwende die neuen Bausteine.
comparing_literals_default_variable_two_without_information=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Wolltest du die Variablen [var]%VARIABLE1[/var] oder [var]%VARIABLE2[/var] im Vergleich verwenden? Dann lege diese in der Kategorie Variable an und verwende die neuen Bausteine.
comparing_literals_default_variable_without_information=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Wolltest du eine Variable [var]%VARIABLE[/var] im Vergleich verwenden? Dann lege diese in der Kategorie Variable an und verwende den neuen Baustein.
comparing_literals_default_without_information=Du vergleichst zwei Texte. Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Ersetze deinen Vergleich durch etwas Passenderes oder entferne die Kontrollstruktur.
comparing_literals_wait_false=Du vergleichst zwei Texte. Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: [FALSE]. Der Code nach dem Warte Baustein wird %ALWAYSNEVER ausgef√ºhrt. Ersetze deinen Vergleich durch etwas Passenderes oder entferne die Kontrollstruktur.
comparing_literals_wait_true=Du vergleichst zwei Texte. Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: [TRUE]. Der Code nach dem Warte Baustein wird %ALWAYSNEVER ausgef√ºhrt. Der Baustein ist √ºberfl√ºssig.
comparing_literals_wait_variable=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Der Code nach dem Warte Baustein wird %ALWAYSNEVER ausgef√ºhrt. Wolltest du eine Variable [var]%VARIABLE[/var] im Vergleich verwenden? Dann lege diese in der Kategorie Variable an und verwende den neuen Baustein.
comparing_literals_wait_variable_exists=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Der Code nach dem Warte Baustein wird %ALWAYSNEVER ausgef√ºhrt. Wolltest du den Baustein f√ºr deine angelegte Variable [var]%VARIABLE[/var] im Vergleich verwenden?
comparing_literals_wait_variable_exists_two=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Deshalb wird der Code nach dem Warte Baustein wird %ALWAYSNEVER ausgef√ºhrt. Wolltest du die angelegte Variable [var]%VARIABLE1[/var] oder [var]%VARIABLE2[/var] im Vergleich verwenden?
comparing_literals_wait_variable_two=Bei deinem Vergleich erh√§ltst du immer dasselbe Ergebnis: %TRUEFALSE%ADDINFODICT. Deshalb wird der Code nach dem Warte Baustein wird %ALWAYSNEVER ausgef√ºhrt. Wolltest du die Variablen [var]%VARIABLE1[/var] oder [var]%VARIABLE2[/var] im Vergleich verwenden? Dann lege diese in der Kategorie Variable an und verwende die neuen Bausteine.
conditional_inside_loop=Toll! Du fragst wiederholt in einer Wiederholung bestimmte Bedingungen ab, du verschachtelst also zwei wichtige Steuerungsbl√∂cke. Damit kannst du auch etwas anspruchsvollere Probleme l√∂sen.
controlled_broadcast_or_stop=Gut gemacht! Um mehr Kontrolle √ºber dein Programm zu haben, fragst du kontinuierlich, ob bestimmte Bedingungen erf√ºllt sind, bevor du eine Nachricht verwendest oder das Programm/Skript stoppst.
coordination=Sehr gut! Du kannst dein Programm und mehrere Skripte bereits gut miteinander koordinieren, das ist f√ºr ein gr√∂√üeres Program sehr wichtig. Am besten geht es mittels Nachrichten und [bc]Warte bis < >[/bc].
correct_broadcast=Toll gemacht! Du hast eine Kommunikation mit Nachrichten richtig umgesetzt, somit kannst du ganz einfach deine Skripte koordinieren.
custom_block_usage=Sehr gut! Du kannst deinen eigenen Block erstellen und verwendest ihn auch in deinem Programm.
custom_block_with_forever=Wenn du in einem eigenen Block [sbi]wiederhole fortlaufend[/sbi] verwendest, wird dieser Block nie wieder verlassen. Die Befehle, die nach deinem Blockaufruf in einem [bc]anderen Skript[/bc] im Programm stehen, k√∂nnen nie ausgef√ºhrt werden.
custom_block_with_termination=Wenn du in dem eigenen Block [sbi]%METHOD[/sbi] alles stoppst oder den aktuellen Klon l√∂schst, werden die Befehle, die nach deinem Blockaufruf von [sbi]%METHOD[/sbi] in einem [bc]anderen Skript[/bc] im Programm stehen, nie ausgef√ºhrt. Entferne den [sbi]stoppe [alles v][/sbi] oder [sbi]l√∂sche diesen Klon[/sbi] Baustein oder verwende einen [sbi]falls < >, dann[/sbi] Baustein, um nicht immer zu stoppen.
dead_code=In deinem Programm befinden sich Bl√∂cke, die keinen Ereignisverarbeiter haben. Sie werden niemals ausgef√ºhrt. Dadurch wird dein Programm un√ºbersichtlicher. Du kannst die Bl√∂cke l√∂schen oder versuchen sie in dein Programm zu integrieren.
delete_clone_in_loop=Dein Programm l√∂scht den Klon im ersten Durchgang der Wiederholung. Die Wiederholung ist also √ºberfl√ºssig und macht dein Programm nur un√ºbersichtlicher. Du kannst die Wiederholung entfernen.
directed_motion=Gut gemacht! Deine Figur l√§sst sich auf Tastendruck gef√ºhrt bewegen, das ist sehr wichtig f√ºr die meisten Spiele.
double_if=Dein Programm enth√§lt zwei aufeinanderfolgende bedingte Anweisungen mit derselben Bedingung. √úberlege, ob du diese zu einem Block zusammenfassen kannst, um das Programm k√ºrzer und verst√§ndlicher zu machen.
duplicate_sprite=In deinem Programm befinden sich exakte Kopien derselben Figur. Das macht das Programm un√ºbersichtlich. Hier k√∂nnte man auch einfach Klone erzeugen.
duplicated_script=In deinem Programm befindet sich das gleiche Skript unn√∂tigerweise doppelt. Das macht das Programm un√ºbersichtlich. Du kannst eines der Skripte l√∂schen.
duplicated_scripts_covering=In deinem Programm befindet sich das gleiche Skript unn√∂tigerweise doppelt. Au√üerdem liegen die Skripte genau so √ºbereinander, dass du nur eines sehen kannst. Dies kann zu unerwartetem Verhalten in deinem Programm f√ºhren. Du kannst eines der Skripte l√∂schen.
empty_control_body=Du hast einen [sbi]%BLOCKNAME[/sbi] verwendet, der keine Bausteine enth√§lt. Dies macht den Code schwieriger zu verstehen. L√∂sche den Baustein, falls er nicht weiter verwendet wird.
empty_custom_block=Du hast einen eigenen Block definiert, der keine Bausteine in seiner Definition enth√§lt. Wenn er aufgerufen wird, passiert nichts. L√∂sche den eigenen Block, falls er nicht weiter verwendet wird.
empty_project=Das gesamte Projekt ist leer. Fang am besten damit an, eine erste Figur hinzuzuf√ºgen.
empty_script=In deiner Figur befindet sich ein Ereignisverarbeiter der keine Bausteine angeh√§ngt hat. Wenn das Ereignis ausgel√∂st wird, geschieht nichts. Wenn nichts geschehen soll, kannst du diesen Baustein l√∂schen. Wenn doch etwas passieren soll, baue dieses Skript entsprechend weiter.
empty_sprite=Die Figur %SPRITE besitzt keinerlei Skripte. Sie kann auf keine Benutzerinteraktion oder Interaktion mit anderen Figuren reagieren. Wenn das beabsichtigt ist, kannst du das einfach lassen. Wenn nicht solltest du √ºberlegen, was die Figur machen soll und daf√ºr Skripte in dieser Figur anlegen.
endless_recursion_broadcast=F√ºhre beim Selbstaufruf eine Bedingung zum Abbruch ein, denn sonst ruft sich das Skript √ºber die Nachricht unendlich lange immer wieder selbst auf.
endless_recursion_procedure=F√ºhre beim Selbstaufruf eine Bedingung zum Abbruch ein, denn sonst ruft sich der eigene Block unendlich lange immer wieder selbst auf.
expression_as_touching_or_color=Der Baustein erwartet als √úbergabewert eine Farbe. Du solltest den eingesetzten Baustein entfernen.
forever_inside_if=Die Endloswiederholung [sbi]wiederhole fortlaufend[/sbi] wird nie verlassen. Alle Bl√∂cke, die in diesem Skript, aber au√üerhalb dieser Endloswiederholung sind, also auch alle Bl√∂cke nach dem [sbi]falls < >, dann[/sbi], werden so nie ausgef√ºhrt. Versuche die innere Endloswiederholung wegzulassen.
forever_inside_loop=Die innere Endloswiederholung [sbi]wiederhole fortlaufend[/sbi] wird nie verlassen. Alle Bl√∂cke, die in diesem Skript, aber au√üerhalb dieser Endloswiederholung sind, werden so nie wieder ausgef√ºhrt. Versuche die innere Endloswiederholung wegzulassen.
gliding_motion=Gut gemacht! Deine Figur l√§sst gleitet auf Tastendruck in eine bestimmte Richtung. Dieses Konzept ist f√ºr viele Spiele wichtig.
hide_without_show=Dein Programm benutzt einen [sbi]verstecke dich[/sbi] Baustein ohne die Figur wieder sichtbar zu machen. Dadurch k√∂nnen keine Ver√§nderungen an der Figur dargestellt werden. Um diese Ver√§nderungen anzeigen zu lassen, musst du einen [sbi]zeige dich[/sbi] Baustein in deinem Programm verwenden.
illegal_parameter_refactor=Der verwendete Parameter besitzt den falschen Typ. Durch das Bearbeiten des eigenen Blocks ist aus dem Parameter mit einem Wahrheitswert ein Parameter mit einem Text oder Nummer geworden. Mache die Bearbeitung r√ºckg√§ngig.
immediate_delete_clone_after_broadcast=Das Skript l√∂scht den Klon sofort nach dem [sbi]sende (%MESSAGE v) an alle[/sbi] Baustein. Das Skript, das durch die Nachricht ausgel√∂st wird und mit dem Baustein [sbi]Wenn ich [%MESSAGE v] empfange[/sbi] beginnt, wird f√ºr diesen Klon der Figur %SPRITE nicht mehr richtig abgearbeitet. Du verwendest besser einen [sbi]sende (%MESSAGE v) an alle und warte[/sbi] Baustein.
immediate_stop_after_say_think=Das Skript stoppt alles sofort nach dem [bc]%SAYTHINK[/bc] Baustein. Der Text wird nie angezeigt. Ersetze den [bc]%SAYTHINK[/bc] Baustein durch einen [sbi]%SAYTHINK ( ) f√ºr ( ) Sekunden[/sbi] Baustein. Damit der Rest des Programms stoppt, f√ºgst du am besten einen [sbi]stoppe [andere Skripte der Figur v][/sbi] Baustein vor dem %SAYTHINK ein.
immediate_stop_after_say_think_multiple=Das Skript stoppt alles sofort nach dem [bc]%SAYTHINK[/bc] Baustein. Der Text wird nie angezeigt. Ersetze den [bc]%SAYTHINK[/bc] Baustein durch einen [sbi]%SAYTHINK ( ) f√ºr ( ) Sekunden[/sbi] Baustein. Damit der Rest des Programms stoppt, f√ºgst du am besten einen [sbi]stoppe [andere Skripte der Figur v][/sbi] Baustein vor dem %SAYTHINK ein. Wenn du alles andere stoppen m√∂chtest, w√§hrend die Figur den [sbi]%SAYTHINK ( ) f√ºr ( ) Sekunden[/sbi] Baustein ausf√ºhrt, musst du au√üerdem andere Figuren mit Hilfe eines [sbi]sende (Nachricht v) an alle[/sbi] Bausteins benachrichtigen, dass auch sie ihre Skripte stoppen sollen.
inappropriate_handler_delete_clone=Das Skript enth√§lt einen [sbi]l√∂sche diesen Klon[/sbi] Baustein. Dieser kann aber nicht ausgef√ºhrt werden, weil im Ereignisverarbeiter nicht klar wird, f√ºr welche Klone er gelten soll. Deswegen muss das Skript entweder mit dem [sbi]Wenn ich als Klon entstehe[/sbi] Baustein oder dem [sbi]Wenn diese Figur angeklickt wird[/sbi] Baustein beginnen oder du verschiebst den [sbi]L√∂sche diesen Klon[/sbi] Baustein in ein anderes Skript, das mit diesen Ereignisverarbeitern beginnt.
initialisation_of_looks_sprite=Gut gemacht! Du sorgst daf√ºr, dass das Aussehen deiner Figur bei Programmstart wieder auf den Anfangszustand zur√ºckgesetzt wird.
initialisation_of_looks_stage=Gut gemacht! Du sorgst daf√ºr, dass das Aussehen deiner B√ºhne bei Programmstart wieder auf den Anfangszustand zur√ºckgesetzt wird.
initialisation_of_position=Gut gemacht! Du sorgst daf√ºr, dass sich deine Figur bei Programmstart wieder am selben Ausgangspunkt befindet.
interrupted_loop_sensing=Der [bc]%BLOCKNAME[/bc] Baustein verhindert w√§hrend seiner Ausf√ºhrung die √úberpr√ºfung der Bedingung im [bc]%THENELSE[/bc] Baustein. Es kann also sein, dass die Bedingung eintritt, aber dein Skript nicht passend reagiert, da es zu diesem Zeitpunkt mit dem '%BLOCKNAME' Baustein besch√§ftigt ist. √úberlege, ob du die Pr√ºfung parallel (in einem eigenen Skript) durchf√ºhren kannst.
key_set_position=Dein Programm setzt jedesmal, wenn du auf die Taste %KEY dr√ºckst, die Position der Figur auf einen bestimmten Wert. Wahrscheinlich hast du versucht die Figur um einen bestimmten Wert zu bewegen. Benutze daf√ºr den Baustein [sbi]√§ndere %XY um ( )[/sbi].
list_usage=Gut gemacht! Du benutzt eine Liste, somit kannst du bereits mit Kollektionen umgehen.
long_script=Dein Skript ist sehr lang. Versuche, es in mehrere k√ºrzere Skripte zu teilen: Teile dein langes Skript so auf, dass jedes k√ºrzere Skript f√ºr eine Teilaufgabe deines Programms zust√§ndig ist. Dadurch beh√§ltst du den √úberblick.
loop_one=Deine Wiederholung wird nur ein einziges Mal durchlaufen. In diesem Fall ist der Wiederholungsbaustein √ºberfl√ºssig, du kannst ihn entfernen und die Bausteine im Inneren direkt in dein Skript einf√ºgen.
loop_sensing=Gut gemacht! Damit du auch ganz sicher kein Ereignis verpasst, fragst du kontinuierlich nach diesem Ereignis in einer endlosen Wiederholung.
loop_zero=Deine Wiederholung wird nie durchlaufen. In diesem Fall ist der Wiederholungsbaustein √ºberfl√ºssig, du kannst ihn und die Bausteine im Inneren entfernen.
matching_parameter=Gut! Du wei√üt, dass du deinen Parameter initialisieren solltest bevor du ihn verwendest.
message_naming=Die Nachricht [bc]%MESSAGE[/bc] hat keinen aussagekr√§ftigen Namen. Du verwendest den Standardnamen oder eine Nachricht, die bereits genutzt wird, gefolgt von einer Zahl. Dadurch wird dein Programm schwerer zu verstehen. Verwende aussagekr√§ftige, eindeutige Nachrichten.
message_never_received=Die Nachricht [bc]%MESSAGE[/bc], die hier gesendet wird, wird nie durch einen [sbi]Wenn ich [Nachricht v] empfange[/sbi] Baustein empfangen. Deshalb passiert nichts in Reaktion auf diese Nachricht. Wenn du eine Nachricht sendest, stelle sicher, dass sie auch von einem [bc]passenden Skript[/bc] empfangen wird.
message_never_sent=Die Nachricht [bc]%MESSAGE[/bc], die hier empfangen werden soll, wird nie gesendet. Dieses Skript wird also nie ausgel√∂st. Wenn du eine Nachricht empfangen willst, musst du eine Nachricht ausw√§hlen, die in einem [bc]anderen Skript[/bc] bereits versendet wird oder eine neue passende Nachricht in einem [bc]anderen Skript[/bc] versenden.
message_never_sent_say_think=Die Nachricht [bc]%MESSAGE[/bc], die hier empfangen werden soll, wird nie gesendet. Dieses Skript wird also nie ausgel√∂st. Du verwendest die Nachricht aber als Text in einem [sbi]%SAYTHINK ( )[/sbi] oder [sbi]%SAYTHINK ( ) f√ºr ( ) Sekunden[/sbi] Baustein in den Figuren: %SPRITES. √úberlege, ob du dort zus√§tzlich einen [sbi]sende [%MESSAGE v] an alle[/sbi] Baustein verwenden willst, um alle zu informieren.
message_never_sent_touching=Die Nachricht [bc]%MESSAGE[/bc], die hier empfangen werden soll, wird nie gesendet. Dieses Skript wird also nie ausgel√∂st. Du verwendest einen [sbi]wird (%SPRITE v) ber√ºhrt?[/sbi] Baustein in den Figuren: %SPRITE. Wenn du eine Nachricht √ºber diese Ber√ºhrung an alle versenden willst, dann musst du dazu zus√§tzlich einen [sbi]sende [%MESSAGE v] an alle[/sbi] Baustein verwenden.
middle_man_broadcast=Wenn man auf eine Nachricht wartet, nur um dann gleich eine andere loszuschicken, ist das ein Code Smell. Der Grund daf√ºr ist, dass das Skript, das auf die erste Nachricht wartet, eigentlich unn√∂tig ist, es ist nur Vermittler zwischen dem originalen Sender und dem finalen Empf√§nger. √úberlege, ob du die Nachricht, auf die das finale Skript wartet, nicht auf die erste gesendete Nachricht umstellen kannst - dann kannst du problemlos das Skript in der Mitte l√∂schen, um unn√∂tigen Code zu vermeiden.
middle_man_procedure=Wenn man einen eigenen Block aufruft, nur um dann gleich einen [bc]anderen eigenen Block[/bc] aufzurufen, ist das ein Code Smell. Der Grund daf√ºr ist, dass das der eigenen Block, der nur einen anderen aufruft, eigentlich unn√∂tig ist, er ist nur Vermittler zwischen dem originalen Aufruf und dem finalen eigenen Block. √úberlege, ob du den ersten Aufruf nicht auf den zweiten eigenen Block umstellen kannst - dann kannst du problemlos den eigenen Block in der Mitte l√∂schen, um unn√∂tigen Code zu vermeiden.
missing_ask=Der [sbi](Antwort)[/sbi] Baustein wird verwendet, aber es wird nie eine Frage gestellt.
missing_backdrop_switch=Wenn du auf einen Wechsel des B√ºhnenbilds reagieren willst, dieses B√ºhnenbild aber nie erscheint, wird das Skript nie ausgef√ºhrt. Stelle sicher, dass du den Wechsel zum B√ºhnenbild auch anordnen.
missing_clone_call=Wenn du das Element [sbi]Wenn ich als Klon entstehe[/sbi] verwendest, aber die Figur nicht geklont wird, wird das Skript nie ausgef√ºhrt. Stelle sicher, dass die Figur auch irgendwo geklont wird.
missing_clone_initialization=Wenn du eine Figur klonst, sie aber kein Skript mit [sbi]Wenn ich als Klon entstehe[/sbi] oder [sbi]Wenn diese Figur angeklickt wird[/sbi] enth√§lt, kann der Klon nichts machen. Verwende ein Skript, das mit einem dieser Bausteine beginnt. Du kannst auch den [sbi]hinterlasse Abdruck[/sbi] Baustein der Malstifterweiterung benutzen, wenn der Klon nichts machen soll.
missing_clone_initialization_delete_clone=Wenn du eine Figur klonst, sie aber kein Skript mit [sbi]Wenn ich als Klon entstehe[/sbi] oder [sbi]Wenn diese Figur angeklickt wird[/sbi] enth√§lt, kann der Klon nichts machen. Du verwendest einen [sbi]l√∂sche diesen Klon[/sbi] Baustein in einem Skript von %SPRITE. Untersuche, ob du dieses Skript sinnvoller mit dem [sbi]Wenn ich als Klon entstehe[/sbi] oder den [sbi]Wenn diese Figur angeklickt wird[/sbi] Baustein beginnst.
missing_clone_initialization_delete_clone_message=Wenn du eine Figur klonst, diese Figur aber kein Skript mit [sbi]Wenn ich als Klon entstehe[/sbi] oder [sbi]Wenn diese Figur angeklickt wird[/sbi] enth√§lt, kann der Klon nichts machen. Du verwendest einen [sbi]l√∂sche diesen Klon[/sbi] Baustein in einem Skript der Figur %SPRITE, das mit dem Empfangen der Nachricht [bc]%MESSAGE[/bc] beginnt. Suche in der Figur %SPRITE nach dem Skript, in dem die Nachricht [bc]%MESSAGE[/bc] versendet wurde. Verwende in diesem Skript statt des vorhandenen Ereignisverarbeiters [bc]%EVENTHANDLER[/bc] den [sbi]Wenn ich als Klon entstehe[/sbi] Baustein oder den [sbi]Wenn diese Figur angeklickt wird[/sbi] Baustein.
missing_clone_initialization_delete_clone_message_multiple=Wenn du eine Figur klonst, diese Figur aber kein Skript mit [sbi]Wenn ich als Klon entstehe[/sbi] oder [sbi]Wenn diese Figur angeklickt wird[/sbi] enth√§lt, kann der Klon nichts machen. Du verwendest einen [sbi]l√∂sche diesen Klon[/sbi] Baustein in einem Skript der Figur %SPRITE, das mit dem Empfangen der Nachricht [bc]%MESSAGE[/bc] beginnt. Suche in der Figur %SPRITE nach den Skripten, in denen die Nachricht [bc]%MESSAGE[/bc] versendet wurde. Verwende in diesen Skripten statt der vorhandenen Ereignisverarbeiter [bc]%EVENTHANDLER[/bc] den [sbi]Wenn ich als Klon entstehe[/sbi] Baustein oder den [sbi]Wenn diese Figur angeklickt wird[/sbi] Baustein.
missing_erase_all=Wenn du in Scratch zeichnest, aber nie l√∂scht, bleibt die Zeichnung auch bei der n√§chsten Ausf√ºhrung erhalten. Stelle sicher, dass du zu Beginn des Programms die alten Zeichnungen mit einem [sbi]l√∂sche alles[/sbi] Baustein l√∂schst.
missing_initialization=In dieser Figur wird %VARIABLE nicht initialisiert bevor der Wert ausgelesen wird, und hat damit beim Start immer den Wert der letzten Ausf√ºhrung. Initialisiere %VARIABLE, indem du zu Beginn eines [bc]passenden Skripts[/bc] den gew√ºnschten Anfangswert zuweist.
missing_initialization_clone=In dieser Figur wird %VARIABLE nicht initialisiert bevor der Wert ausgelesen wird. Initialisiere %VARIABLE, indem du zu Beginn eines [bc]passenden Skripts[/bc] den gew√ºnschten Anfangswert zuweist.
missing_loop_mouse_position_direction=Wenn du eine Figur zur Maus drehen willst, willst du das wahrscheinlich √ºber die ganze Dauer des Programs machen. Damit das klappt musst du die Drehung immer wieder ausf√ºhren und nicht nur einmal. Dazu musst du den Drehungsbaustein noch mit einem [sbi]wiederhole fortlaufend[/sbi] Baustein umschlie√üen.
missing_loop_mouse_position_motion=Wenn du eine Figur mit der Maus steuern willst, willst du das wahrscheinlich √ºber die ganze Dauer des Programs machen. Damit das klappt musst du die Bewegung immer wieder ausf√ºhren und nicht nur einmal. Dazu musst du den Bewegungsbaustein noch mit einem [sbi]wiederhole fortlaufend[/sbi] Baustein umschlie√üen.
missing_loop_sensing=Die hervorgehobene Bedingung wird in dem Skript nur einmal √ºberpr√ºft. Das Skript l√§uft dadurch zu schnell durch. Umschlie√üe die bedingte Anweisung mit dem Baustein [sbi]wiederhole fortlaufend[/sbi], um etwas wiederholt zu √ºberpr√ºfen.
missing_loop_sensing_variable=Wenn etwas beim Eintritt eines bestimmten Variablenwertes passieren soll, ben√∂tigst du eine Wiederholung, damit die √úberpr√ºfung kontinuierlich stattfindet. Nutze einen Wiederholungsbaustein.
missing_pen_down=Du hast einen [sbi]schalte Stift aus[/sbi] Baustein verwendet, aber keinen [sbi]schalte Stift ein[/sbi]. Wenn du in Scratch etwas zeichnen willst, vergiss nicht, den [sbi]Schalte Stift ein[/sbi] Baustein zu verwenden.
missing_pen_up=Du hast einen [sbi]schalte Stift ein[/sbi] Baustein verwendet, aber keinen [sbi]schalte Stift aus[/sbi]. Das kann zu ungewollten Linien in der Zeichnung f√ºhren. Wenn du den Malstift irgendwo einschaltest, stelle sicher, dass er auch wieder ausgeschaltet wird.
missing_resource=Deinem Programm fehlt ein Bild oder ein Ton, den du benutzen willst. W√§hle ein anderes Bild oder einen anderen Ton. Alternativ kannst du auch einen neuen Ton oder ein neues Bild hochladen.
missing_termination=Wird eine Wiederholung verwendet und die Abbruchbedingung vergessen, so f√ºhrt das Programm die Wiederholung unendlich lang aus. Bl√∂cke danach werden nie erreicht. Vergiss nicht, die Abbruchbedingung in deiner Wiederholung einzuf√ºgen.
missing_wait_condition=In deinem [sbi]Warte bis < >[/sbi] Baustein fehlt die Bedingung, auf die gewartet werden soll.
mouse_follower=Super! Deine Figur kann dem Mauszeiger folgen. Das kann f√ºr einige Spiele ein gutes Konzept sein.
movement_in_loop=Gut gemacht! Die Bewegungen deiner Figur wirken sehr fl√ºssig, da du die Bewegung in einer Wiederholung ausf√ºhrst.
multiple_attribute_modifications=Es gibt mehrere √Ñnderungen der gleichen Variable oder des gleichen Attributs hintereinander, die zusammengefasst werden k√∂nnten.
multiple_attribute_modifications_custom=Es gibt mehrere √Ñnderungen von %VARIABLE hintereinander, die zusammengefasst werden k√∂nnten.
multiple_attribute_modifications_saythink=Es gibt mehrere [sbi]sage ( )[/sbi] oder [sbi]denke ( )[/sbi] Bl√∂cke hintereinander ohne Verz√∂gerung. Nur wenn du einen [sbi]sage ( ) f√ºr ( ) Sekunden[/sbi] oder [sbi]denke ( ) f√ºr ( ) Sekunden[/sbi] Block verwendest, wird man die erste Nachricht sehen.
nested_conditional_checks=Sehr gut! Du benutzt verschachtelte Bedingungen, also ineinander verschachtelte [sbi]falls < >, dann[/sbi]. Damit kannst du auch etwas anspruchsvollere Probleme l√∂sen.
nested_loops=Verschachtle keine Wiederholungen ineinander, denn das kann zu unerwarteten Problemen f√ºhren. Versuche nicht notwendige Wiederholungen wegzulassen.
nested_loops_perfume=Sehr gut! Du benutzt ineinander verschachtelte Wiederholungen. Damit kannst du auch etwas anspruchsvollere Probleme l√∂sen.
no_working_scripts=Deine Figur enth√§lt nur lose Bl√∂cke und Ereignisbausteine. Verbinde den Ereignisbaustein mit deinem restlichen Bl√∂cken damit die Figur auf die Ereignisse reagieren kann.
object_follower=Super! Deine Figur kann anderen Objekten folgen. Das kann f√ºr einige Spiele ein gutes Konzept sein.
orphaned_parameter=Wenn du bei deinem eigenen Block ein Eingabefeld nachtr√§glich l√∂schst, stelle sicher, dass du alle Verwendungen des Eingabefeldes auch l√∂schst.
parallelisation=Toll! Du startest mindestens zwei Skripte durch das selbe Ereignis. Das Konzept von Parallelisierung kannst du somit bereits gut umsetzen.
parameter_out_of_scope=Den Wert eines Eingabefelds kannst du lediglich innerhalb eines eigenen Blocks verwenden.
position_equals_check=Die Position einer Figur in Scratch beschreibt ihren Mittelpunkt. Es ist sehr unwahrscheinlich, dass die %COORDINATE Koordinate eines Objekts den genauen Wert des Vergleichs annimmt. Benutze stattdessen eine passende N√§herung mit [LEQ] bzw. [GEQ].
position_equals_check_dist=Die Position einer Figur in Scratch beschreibt ihren Mittelpunkt. Es ist sehr unwahrscheinlich, dass die Entfernung zweier Objekte den genauen Wert des Vergleichs annimmt. Benutze stattdessen eine passende N√§herung mit [LEQ] bzw. [GEQ].
position_equals_check_zero_mouse=Die Entfernung einer Figur zum Mauszeiger in Scratch von Mittelpunkt zu Mittelpunkt gemessen. Es ist sehr unwahrscheinlich, dass die Mittelpunkte beider Objekte jemals exakt √ºbereinander liegen. Entferne das [EQ] und benutze stattdessen eine passende N√§herung mit [LEQ] oder verwende einen ber√ºhren-Baustein [sbi]wird ( v) ber√ºhrt?[/sbi], [sbi]wird Farbe [#11ff33] ber√ºhrt?[/sbi], [sbi]Farbe [#11ff33] ber√ºhrt [#11ff33]?[/sbi] aus dem Bereich F√ºhlen.
position_equals_check_zero_sprites=Die Entfernung zweier Figuren wird in Scratch von Mittelpunkt zu Mittelpunkt gemessen. Es ist sehr unwahrscheinlich, dass die Mittelpunkte zweier Figuren jemals exakt √ºbereinander liegen. Entferne das [EQ] und benutze stattdessen eine passende N√§herung mit [LEQ] oder verwende einen ber√ºhren-Baustein [sbi]wird ( v) ber√ºhrt?[/sbi], [sbi]wird Farbe [#11ff33] ber√ºhrt?[/sbi], [sbi]Farbe [#11ff33] ber√ºhrt [#11ff33]?[/sbi] aus dem Bereich F√ºhlen.
recursive_cloning=Ein Klon sollte keine weiteren Klone von sich selbst erzeugen, da sonst im schlimmsten Fall unendlich viele Klone entstehen.
same_variable_different_sprite=Der gleiche Variablenname wird in mehreren Figuren verwendet. Das kann Verwirrung erzeugen. Stelle sicher eindeutige Namen zu verwenden.
say_sound_synchronisation=Toll gemacht! Um deine Figur sprechen zu lassen, spielst du einen Klang genau zur gleichen Zeit ab, in der deine Figur auch in einer Sprechblase redet. Das ist ein tolles Feature.
sequential_actions=Das Programm enth√§lt wiederholt eine Sequenz gleicher Anweisungen. Man k√∂nnte das Programm mit einer Wiederholung vereinfachen.
sprite_naming=Die Figur %SPRITE hat keinen aussagekr√§ftigen Namen, sondern den Namen einer anderen Figur gefolgt von einer Zahl. Dadurch wird dein Programm schwerer zu verstehen. Gib deinen Figuren aussagekr√§ftige, eindeutige Namen.
sprite_naming_default=Die Figur %SPRITE hat keinen aussagekr√§ftigen Namen, sondern den Standardnamen. Dadurch wird dein Programm schwerer zu verstehen. Gib deinen Figuren aussagekr√§ftige, eindeutige Namen.
stuttering_movement=Dr√ºckt man eine Taste l√§nger, dann erwartet man eine andauernde Ereignisverarbeitung. Leider tritt jedoch eine Verz√∂gerung zwischen der ersten und der zweiten Verarbeitung auf, wodurch die Bewegung nicht fl√ºssig ist. Du kannst diese Verz√∂gerung umgehen, indem du mit dem Baustein [sbi]<Taste (%KEY v) gedr√ºckt?>[/sbi] aus der Kategorie F√ºhlen arbeitest. Dazu musst du die Bedingung [sbi]falls <Taste (%KEY v) gedr√ºckt?>, dann[/sbi] innerhalb des Bausteins [sbi]wiederhole fortlaufend[/sbi] √ºberpr√ºfen und statt des Ereignisverarbeiters [sbi]Wenn Taste [ v] gedr√ºckt wird[/sbi] den Ereignisverarbeiter [sbi]Wenn die gr√ºne Flagge angeklickt[/sbi] verwenden.
terminated_loop=Die Wiederholung wird unterbrochen (z.B. durch einen Stop-Baustein) und wird gar nicht wiederholt.
timer=Super! Du benutzt eine eigene Variable als eine Art Z√§hler in deiner Wiederholung. Du hast Wiederholungen und den Umgang mit ihnen schon sehr gut verstanden.
type_error=Du vergleichst Werte, die nicht vergleichbar sind.
type_error_weird_distance=Du benutzt einen Baustein in [sbi](Entfernung von ( v))[/sbi], zu dem du keine Entfernung messen kannst. Verwende einen Figurnamen oder die Mauszeiger Option aus den vorgegebenen M√∂glichkeiten des [sbi](Entfernung von ( v))[/sbi] Bausteins.
unnecessary_boolean_true=Du vergleichst einen Wahrheitsblock mit dem Wert %VALUE. Du k√∂nntest den Wahrheitsblock auch ohne Vergleich verwenden.
unnecessary_boolean_false=Du vergleichst einen Wahrheitsblock mit dem Wert %VALUE. Du k√∂nntest den Wahrheitsblock auch ohne Vergleich in ein [sbi]not < >[/sbi] einsetzen.
unnecessary_glide=Du benutzt einen [sbi]gleite in ( ) Sek. zu ( v)[/sbi] Baustein. Da der Zeitwert 0 ist, wird die Bewegung sofort ausgef√ºhrt. Du kannst stattdessen einen [sbi]gehe zu ( v)[/sbi] Baustein verwenden.
unnecessary_glide_xy=Du benutzt einen [sbi]gleite in ( ) Sek. zu x: ( ) y: ( )[/sbi] Baustein. Da der Zeitwert 0 ist, wird die Bewegung sofort ausgef√ºhrt. Du kannst stattdessen einen [sbi]gehe zu x: ( ) y: ( )[/sbi] Baustein verwenden.
unnecessary_if=Du benutzt zwei [sbi]falls < >, dann[/sbi] Bausteine nacheinander mit den selben Bl√∂cken im Inneren. Du kannst das vereinfachen, indem du einen [sbi]<< > oder < >>[/sbi] Baustein verwendest und die Bedingungen in einem einzelnen [sbi]falls < >, dann[/sbi] Baustein zusammenfasst.
unnecessary_if_after_until=Du benutzt einen [sbi]falls < >, dann[/sbi] Baustein nach einem [sbi]wiederhole bis < >[/sbi] Baustein mit der selben Bedingung. Die Bausteine im Inneren des [sbi]falls < >, dann[/sbi] Bausteins werden immer ausgef√ºhrt. Du kannst den [sbi]falls < >, dann[/sbi] Baustein l√∂schen.
unnecessary_if_after_until_else=Du benutzt einen [sbi]falls < >, dann sonst[/sbi] Baustein nach einem [sbi]wiederhole bis < >[/sbi] Baustein mit der selben Bedingung. Die Bausteine in der oberen H√§lfte des [sbi]falls < >, dann[/sbi] Bausteins werden immer ausgef√ºhrt. Du kannst den [sbi]falls < >, dann[/sbi] Baustein l√∂schen.
unnecessary_message=Du benutzt einen [sbi]sende (%MESSAGE v) an alle[/sbi] Baustein sofort nach einem Ereignisverarbeiter. Du kannst stattdessen einfach die Skripte, die mit [sbi]Wenn ich [%MESSAGE v] empfange[/sbi] beginnen, mit dem gleichen Ereignisverarbeiter starten.
unnecessary_move=Du benutzt einen Bewegungsbaustein, der die Position nicht ver√§ndert, du kannst ihn weglassen.
unnecessary_rotation=Deine Drehung bewirkt keinen Unterschied in der Ausrichtung deiner Figur, du kannst den Baustein weglassen.
unnecessary_say=Du benutzt einen [sbi]sage ( ) f√ºr ( ) Sekunden[/sbi] Baustein. Da der Zeitwert 0 ist, hat der Baustein keinen Effekt. Du kannst ihn l√∂schen.
unnecessary_size_change=Dein Baustein bewirkt keinen Unterschied auf die Gr√∂√üe deiner Figur, du kannst den Baustein weglassen.
unnecessary_stop_script=Du benutzt einen [sbi]stop [this script v][/sbi] Baustein am Ende eines Skripts. Du kannst ihn l√∂schen.
unnecessary_think=Du benutzt einen [sbi]denke ( ) f√ºr ( ) Sekunden[/sbi] Baustein. Da der Zeitwert 0 ist, hat der Baustein keinen Effekt. Du kannst ihn l√∂schen.
unnecessary_wait=Du benutzt einen [sbi]warte ( ) Sekunden[/sbi] Baustein. Da der Wert 0 ist, hat der Baustein keinen Effekt. Du kannst ihn l√∂schen.
unused_custom_block=Du hast einen eigenen Block erstellt, den du nirgends verwendest. Das macht das Programm un√ºbersichtlich. Du kannst den eigenen Block l√∂schen.
unused_parameter=Du hast einen Parameter angelegt, den du nicht im eigenen Block verwendest. Das macht den eignen Block den un√ºbersichtlich. Du kannst den Parameter l√∂schen.
unused_variables=Du hast eine Variable [var]%VARIABLE[/var] definiert, die du an keiner Stelle deines Projekts verwendest. Das macht das Projekt un√ºbersichtlich. L√∂sche die Variable [var]%VARIABLE[/var] oder nutze die Bausteine [sbi]setze [%VARIABLE v] auf ( )[/sbi], [sbi]√§ndere [%VARIABLE v] um ( )[/sbi] in deinem Projekt."
unused_variables_list=Du hast eine Liste [var]%VARIABLE[/var] definiert, die du an keiner Stelle deines Projekts verwendest. Das macht das Projekt un√ºbersichtlich. L√∂sche die Liste [var]%VARIABLE[/var] oder nutze die Bausteine [sbi]f√ºge ( ) zu [%VARIABLE v] hinzu[/sbi], [sbi]f√ºge ( ) bei ( ) in [%VARIABLE v] ein[/sbi] in deinem Projekt."
useful_position_check=Gut aufgepasst! In Scratch sind die Werte f√ºr die X- und Y-Koordinaten sehr genau und mit vielen Nachkommastellen. Einen genauen [EQ] -Abgleich mit solchen Zahlen zu machen, ist problematisch. Hier hast du alles richtig gemacht und nur mit [LEQ] bzw. [GEQ] -Operatoren gearbeitet.
useless_blocks_sprite=Du hast einen Baustein verwendet, der nicht f√ºr Figuren gedacht ist. Der Baustein zeigt nur bei Verwendung in der B√ºhne Wirkung. Du kannst den Baustein also einfach entfernen.
useless_blocks_stage=Du hast einen Baustein verwendet, der nicht f√ºr die B√ºhne gedacht ist. Der Baustein zeigt nur bei Verwendung in Figuren Wirkung. Du kannst den Baustein also einfach entfernen.
useless_wait=Du hast einen [sbi]warte () Sekunden[/sbi] Baustein ohne folgende Bausteine im selben Skript. Der Baustein hat also keinen Effekt. Du solltest entweder dem Warten durch folgende Bausteine einen Sinn geben oder es ganz entfernen.
valid_termination=Du hast eine Abbruchbedingung in deine Wiederholung eingebaut, somit l√§uft die Wiederholung auch nicht unendlich lange.
variable_as_literal=Du hast den Namen einer Variable als Text verwendet. Wolltest Du eigentlich den Variablen Baustein [var]%VARIABLE[/var] verwenden? [sbVariables]
variable_initialization_race=Die gleiche Variable wird beim gleichen Ereignis an verschiedenen Stellen initialisiert. Wenn Scratch die Reihenfolge der Skripts √§ndert, kann sich das Ergebnis √§ndern. Versuche nur an einer Stelle die Werte zuzuweisen.
waiting_check_stop=Super! Du wartest auf das Eintreten einer Bedingung zur Beendigung deines Programs.
# questions
block_controlling_loop=Welcher dieser Bl√∂cke kontrolliert, wie oft die Wiederholung ausgef√ºhrt wird?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
element_in_loop_body=Welche dieser Elemente sind im Rumpf der Wiederholung?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
element_in_loop_condition=Welche dieser Elemente sind Teil der Bedingung?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
if_block_condition=Welcher dieser Bl√∂cke ist die Bedingung des Falls Blocks?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
#if_else_statement_execution=Welche Gruppe von Bl√∂cken wird ausgef√ºhrt, wenn [sbi]%CONDITION[/sbi] [%VARIABLE] ist?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
if_then_statement_execution=Wird [sbi]%STATEMENT[/sbi] in diesem [IF] Block ausgef√ºhrt, wenn [sbi]%CONDITION[/sbi] [%VARIABLE] ist?[a-y]%ANSWER[/a-y]
purpose_of_forever_loop=Erkl‰re den Zweck dieser Wiederholung.[a-f]
purpose_of_program=Beschreibe, was dieses Program macht.[a-f]
purpose_of_script=Was ist der Zweck dieses Skripts?[a-f]
purpose_of_variable=Was ist die Rolle der Variable [var]%VARIABLE[/var] im Programm?[a-f]
repeat_times_literal_execution=Wie oft wird [sbi]%STATEMENT[/sbi] ausgef√ºhrt?[a-n]%ANSWER[/a-n]
scripts_for_actor=Wie viele Skripte hat %ACTOR?[a-n]%ANSWER[/a-n]
scripts_in_program=Wie viele Skripte hat das ganze Programm?[a-n]%ANSWER[/a-n]
scripts_triggered_by_event=Wie viele Skripte werden im ganzen Programm ausgef√ºhrt, wenn [sbi]%EVENT[/sbi] passiert?[a-n]%ANSWER[/a-n]
#scripts_triggered_by_statement=Welche Skripte werden ausgef√ºhrt, nachdem dieser Block ausgef√ºhrt wird?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
script_execution_order_different_actors=Das erste Skript geh√∂rt zu %VARIABLE1 und das zweite Skript zu %VARIABLE2.%CONDITION Wenn [sbi]%EVENT[/sbi] eintritt, welches der Skripte wird zuerst ausgel√∂st?[a-c][choices]Das Skript das zu %CHOICES geh√∂rt.[/choices][solutions]Das Skript das zu %ANSWER geh√∂rt.[/solutions][/a-c]
script_execution_order_same_actor=Diese Skripte sind aus derselben Figur. Wenn [sbi]%EVENT[/sbi] eintritt, kann man sagen welches der Skripte zuerst ausgef√ºhrt wird?[a-y]%ANSWER[/a-y]
#script_to_set_variable=Welches Skript aus dem ganzen Programm setzt den Wert der Variable [var]%VARIABLE[/var]?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
set_variable=Welchen Wert hat die Variable [var]%VARIABLE[/var], nachdem dieser Block ausgef√ºhrt wurde?[a-s]%ANSWER[/a-s]
statements_in_if_statement=Welche dieser Bl√∂cke sind in einem [IF] Block?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
statement_triggers_event=Welche dieser Bl√∂cke l√∂sen dieses Skript aus?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
variable_for_actor=Zu welcher Figur geh√∂rt die Variable [var]%VARIABLE[/var]?[a-c][choices]%CHOICES[/choices][solutions]%ANSWER[/solutions][/a-c]
variable_in_script=Gib die Namen der Variablen in diesem Skript an.[a-s]%ANSWER[/a-s]
# mBlock
ambient_light_in_bounds=Toll! Du misst das Umgebungslicht in einem Bereich der vom Sensor erfasst werden kann.
ambient_light_out_of_bounds=Du versuchst das Umgebungslicht in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende einen Lichtwert zwischen 0 und 100.
battery_level_in_bounds=Toll! Du misst die Batterieladung in einem Bereich der erfasst werden kann.
battery_level_out_of_bounds=Du versuchst die Batterieladung des Roboters in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende einen Ladungswert zwischen 0 und 100.
codey_upload_stop_timed=Wenn das "Stopp alles" Script ausgef\u00FChrt wird, w\u00E4hrend ein zeitlich begrenzter Block l\u00E4uft, wird dieser nicht mehr abgeschalten.
codey_upload_stop_timed_possible=Dieser Code kann als upload ausgef\u00FChrt werden. Wenn dabei das "Stopp alles" Script ausgef\u00FChrt wird, w\u00E4hrend ein zeitlich begrenzter Block l\u00E4uft, wird dieser nicht mehr abgeschalten.
color_detection_in_bounds=Toll! Du vergleichst den Farbwert in einem Bereich der vom Sensor erfasst werden kann.
color_detection_out_of_bounds=Du versuchst einen Farbwert zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende eine ganze Zahl zwischen 0 und 255.
color_setting_in_bounds=Toll! Du setzt die Farbe in einem Bereich der dargestellt werden kann.
color_setting_out_of_bounds=Du versuchst einen Farbwert zu setzen, der au\u00DFerhalb des m√∂glichen Bereichs liegt. Verwende eine ganze Zahl zwischen 0 und 255.
detect_repeat_in_loop=Inputs werden in einem schnellen Loop abgefragt, welcher keine wait Statements enth\u00E4lt. Dies f\u00FChrt dazu, dass Inputs mehrfach ausgelesen werden und Code mehrfach ausgef\u00FChrt wird.
gear_potentiometer_in_bounds=Gro\u00DFartig! Du misst den Potentiometerwert des Getriebes in einem Bereich der vom Roboter erfasst werden kann.
gear_potentiometer_out_of_bounds=Du versuchst den Potentiometerwert des Getriebes des Roboters in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende eine ganze Zahl zwischen 0 und 100.
interrupted_loop_sensing_robot=Der [bc]%BLOCKNAME[/bc] Baustein verhindert w\u00E4hrend seiner Ausf\u00FChrung die \u00DCberpr\u00FCfung der Bedingung im [bc]%THENELSE[/bc] Baustein. Es kann also sein, dass die Bedingung eintritt, aber dein Skript nicht passend reagiert, da es zu diesem Zeitpunkt mit dem '%BLOCKNAME' Baustein besch\u00E4ftigt ist. \u00DCberlege, ob du die Pr\u00FCfung parallel (in einem eigenen Skript) durchf\u00FChren kannst.
led_off_script=Super! Du hast ein Skript, um die LEDs ausschalten zu k\u00F6nnen.
led_off_script_missing=LEDs k\u00F6nnen angeschalten werden, aber es fehlt ein Skript, welches sie wieder abschaltet.
line_following_in_bounds=Gro\u00DFartig! Du misst mit dem Linienverfolgungssensor einen Wert der im Messbereichs des Sensors liegt.
line_following_out_of_bounds=Du versucht mit dem Linienverfolgungssensor einen Wert zu messen, der au\u00DFerhalb des Messbereichs des Sensors liegt. Verwende nur ganze Zahlen zwischen 0 und 3.
loop_sensing_robot=Gut gemacht! Damit du auch ganz sicher kein Ereignis verpasst, fragst du kontinuierlich nach diesem Ereignis in einer endlosen Wiederholung.
looped_statement_not_stopped=Ressourcen, wie Motoren oder Lampen, werden durch ihr jeweiliges stopp Statement nicht gestoppt, wenn das ausf\u00FChrende Statement in einer Schleife ist. Hier wird ein stoppe alle Statement ben\u00F6tigt.
loudness_in_bounds=Gro\u00DFartig! Du vergleichst die Lautst\u00E4rke mit Werten im Messbereich des Sensors.
loudness_out_of_bounds=Du versuchst die Lautst\u00E4rke in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende einen Lautst\u00E4rkewert zwischen 0 und 100.
matrix_off_script=Super! Du hast ein Skript, um die LED Matrix ausschalten zu k\u00F6nnen.
matrix_off_script_missing=Matrix kann angeschalten werden, aber es fehlt ein Skript, welches sie wieder abschaltet.
missing_loop_robot_sensing=Die hervorgehobene Bedingung wird in dem Skript nur einmal \u00FCberpr\u00FCft. Das Skript l\u00E4uft dadurch zu schnell durch. Umschlie\u00DFe die bedingte Anweisung mit dem Baustein [sbi]wiederhole fortlaufend[/sbi], um etwas wiederholt zu \u00FCberpr\u00FCfen.
motor_low_power=MBot Motoren brauchen mindestens 50% Power um zuverl\u00E4ssig fahren zu k\u00F6nnen.
motor_off_script=Super! Du hast ein Skript, um die Motoren ausschalten zu k\u00F6nnen.
motor_power_in_bounds=Super! Du verwendest eine Leistungsangabe im Leistungsbereich des Motors.
motor_power_minus=Du verwendest eine negative Leistungsangabe f\u00FCr den Motor. Der Roboter f\u00FChrt damit in die entgegengesetzte Richtung. Um das Program lesbarer zu machen, solltest du den Block f\u00FCr diese Richtung verwenden.
motor_power_out_of_bounds=Motorleistung wird in Prozent angegeben und kann sich deswegen nur zwischen 0 und 100 befinden.
motor_stop_script_missing=Motor kann angeschalten werden, aber es fehlt ein Skript, welches ihn wieder abschaltet.
multiple_attribute_modifications_robot=Es gibt mehrere \u00C4nderungen der gleichen Variable oder des gleichen Attributs hintereinander, die zusammengefasst werden k\u00F6nnten.
multiple_attribute_modifications_custom_robot=Es gibt mehrere \u00C4nderungen von %VARIABLE hintereinander, die zusammengefasst werden k\u00F6nnten.
parallel_board_launch_script=MBots k\u00F6nnen im Hochlademodus keine parallelen Skripte ausf\u00FChren.
parallel_resource_use=Output Ressourcen, wie Motoren oder Lampen, k\u00F6nnen zu Problemen f\u00FChren, wenn sie von zwei Skripten parallel angesteuert werden.
parallelisation_robot=Toll! Du startest mindestens zwei Skripte durch das selbe Ereignis. Das Konzept von Parallelisierung kannst du somit bereits gut umsetzen.
pitch_angle_in_bounds=Super! Du vergleichst den Pitchwinkel im Messbereich des Sensors.
pitch_angle_out_of_bounds=Du versuchst den Pitchwinkel des Roboters in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende eine ganze Zahl zwischen -180 und 180.
rocky_light_off_script=Super! Du hast ein Skript, um das Rocky Licht ausschalten zu k\u00F6nnen.
rocky_light_off_script_missing=Codey Licht kann angeschalten werden, aber es fehlt ein Skript, welches es wieder abschaltet.
roll_angle_in_bounds=Gro\u00DFartig! Du vergleichst den Rollwinkel im Messbereich des Sensors.
roll_angle_out_of_bounds=Du versuchst den Rollwinkel des Roboters in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende eine ganze Zahl zwischen -90 und 90.
sensor_value_equals=Sensoren k\u00F6nnen selten exakte, zuverl\u00E4ssige Werte messen. Hierf\u00FCr sollten Wertebereiche verwendet werden.
shaking_strength_in_bounds=Gro\u00DFartig! Du vergleichst die Vibrationsst\u00E4rke im Messbereich des Sensors.
shaking_strength_out_of_bounds=Du versuchst die Vibrationsst\u00E4rke in einem Bereich zu messen, der au\u00DFerhalb des Messbereichs liegt. Verwende eine ganze Zahl zwischen 0 und 100.
timed_statement_in_live_loop=Wenn eine zeitlich begrenze Aktion alleine in einer Wiederholungsschleife ausgef\u00FChrt wird, dann stottert diese im Live Modus.
timed_statement_in_possible_live_loop=Dieser Code kann im Live Modus ausgef\u00FChrt werden. Wenn eine zeitlich begrenze Aktion alleine in einer Wiederholungsschleife ausgef\u00FChrt wird, dann stottert diese im Live modus.
ultra_sonic_in_bounds=Gro\u00DFartig! Du vergleichst den Wert des Ultraschallsensors im Messbereich.
ultra_sonic_out_of_bounds=Du versuchst mit dem Ultraschallsenor eine Entfernung zu messen, die au\u00DFerhalb des Messbereichs des Senors liegt. Verwende eine Entfernung im Bereich zwischen 3cm und 400cm.
unnecessary_time_robot=Du benutzt einen Baustein der √ºber eine bestimmte Zeit ausgef√ºhrt wird. Da der Zeitwert 0 ist, hat der Baustein keinen Effekt. Du kannst ihn l\u00F6schen.
